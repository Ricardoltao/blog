---
title: 动态规划
date: 2020-03-06 15:45:49
tags: 动态规划
categories: 数据结构与算法
---
# 动态规划算法

## 前言

对于算法之类的问题，知识点还是有点薄弱，今天就来认识一下什么是动态规划算法，查漏补缺，每天学习一点。

动态规划是一种分阶段解决问题的数学思想，简单的来说就是**大事化小，小事化了**。

动态规划中有三个核心概念：

+ 最优子结构
+ 边界
+ 状态转移公式

**举一个例子**：

![dp](dp.png)

假设只能通过road1或road2两条路径到达终点，到达road1有x条路径，到达road2有y条路径，所以到达终点的可能性就是 x+y 

**另一个列子**：

有一个只能容纳10本书的单层书架，你每次只能放1本或2本书。要求用程序求出你将书架填满一共有多少种方法。

从书架上为0到放满的方法总数**等于**0本到9本的方法总数**加**0到8本的方法总数。也就是F(10)=F(8)+F(9)，依次类推得到：**F(n) = F(n-1)+F(n-2)（n>=3）**

+ 最优子结构：F(10)=F(8)+F(9)
+ 边界：当书架直接只有1 或 2 本书要放时，我们可以直接得到结果，无需花间，我们称F(1)和F(2)为边界。
+ 状态转移公式：F(n) = F(n-1)+F(n-2)



## leecode

[原题地址](https://leetcode-cn.com/problems/unique-paths-ii/)

### 不同路径II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![robot_maze](robot_maze.png)

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**说明：** *m* 和 *n* 的值均不超过 100。

> 示例 1:
>
> 输入:
> [
>   [0,0,0],
>   [0,1,0],
>   [0,0,0]
> ]
> 输出: 2
> 解释:
> 3x3 网格的正中间有一个障碍物。
> 从左上角到右下角一共有 2 条不同的路径：
>
> 1. 向右 -> 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右 -> 向右
>
> 

```js
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
    let m = obstacleGrid.length,
        n = obstacleGrid[0].length;
    if(obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0;
    //用数组记录每一次的结果
    let dp = [];
    for(let i=0;i<m;i++){
        dp[i]=[];
        for(let j=0;j<n;j++){
            // 若该节点为0，表示通向该节点的路径为0
            if(obstacleGrid[i][j] == 1){
                dp[i][j]=0;
            }else if(i==0){
                //对于n行1列来说，该节点的路径是依赖于左边的节点
                dp[i][j] = dp[i][j-1] == 0 ? 0 : 1;
            }else if(j==0){
                dp[i][j] = dp[i-1][j] == 0 ? 0 : 1;
            }else{
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    return dp[m-1][n-1]    
};
```

## 参考连接

>https://juejin.im/post/5cde316f6fb9a07ed9118f01#heading-2